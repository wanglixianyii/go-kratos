// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.6.2
// - protoc             v3.19.4
// source: authority/v1/authority.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationAuthorityCreateMenu = "/authority.api.v1.authority/CreateMenu"
const OperationAuthorityDeleteMenu = "/authority.api.v1.authority/DeleteMenu"
const OperationAuthorityDetailMenu = "/authority.api.v1.authority/DetailMenu"
const OperationAuthorityMenuList = "/authority.api.v1.authority/MenuList"
const OperationAuthorityUpdateMenu = "/authority.api.v1.authority/UpdateMenu"

type AuthorityHTTPServer interface {
	CreateMenu(context.Context, *CreateMenuReq) (*CreateMenuResp, error)
	DeleteMenu(context.Context, *DeleteMenuReq) (*DeleteMenuResp, error)
	DetailMenu(context.Context, *DetailMenuReq) (*DetailMenuResp, error)
	// MenuList 菜单
	MenuList(context.Context, *MenuListReq) (*MenuListResp, error)
	UpdateMenu(context.Context, *UpdateMenuReq) (*UpdateMenuResp, error)
}

func RegisterAuthorityHTTPServer(s *http.Server, srv AuthorityHTTPServer) {
	r := s.Route("/")
	r.POST("/authority/v1/menu/list", _Authority_MenuList0_HTTP_Handler(srv))
	r.POST("/authority/v1/menu/create", _Authority_CreateMenu0_HTTP_Handler(srv))
	r.PUT("/authority/v1/menu/update", _Authority_UpdateMenu0_HTTP_Handler(srv))
	r.DELETE("/authority/v1/menu/delete", _Authority_DeleteMenu0_HTTP_Handler(srv))
	r.POST("/authority/v1/menu/detail", _Authority_DetailMenu0_HTTP_Handler(srv))
}

func _Authority_MenuList0_HTTP_Handler(srv AuthorityHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MenuListReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthorityMenuList)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MenuList(ctx, req.(*MenuListReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MenuListResp)
		return ctx.Result(200, reply)
	}
}

func _Authority_CreateMenu0_HTTP_Handler(srv AuthorityHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateMenuReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthorityCreateMenu)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateMenu(ctx, req.(*CreateMenuReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateMenuResp)
		return ctx.Result(200, reply)
	}
}

func _Authority_UpdateMenu0_HTTP_Handler(srv AuthorityHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateMenuReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthorityUpdateMenu)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateMenu(ctx, req.(*UpdateMenuReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateMenuResp)
		return ctx.Result(200, reply)
	}
}

func _Authority_DeleteMenu0_HTTP_Handler(srv AuthorityHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteMenuReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthorityDeleteMenu)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteMenu(ctx, req.(*DeleteMenuReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteMenuResp)
		return ctx.Result(200, reply)
	}
}

func _Authority_DetailMenu0_HTTP_Handler(srv AuthorityHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DetailMenuReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthorityDetailMenu)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DetailMenu(ctx, req.(*DetailMenuReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DetailMenuResp)
		return ctx.Result(200, reply)
	}
}

type AuthorityHTTPClient interface {
	CreateMenu(ctx context.Context, req *CreateMenuReq, opts ...http.CallOption) (rsp *CreateMenuResp, err error)
	DeleteMenu(ctx context.Context, req *DeleteMenuReq, opts ...http.CallOption) (rsp *DeleteMenuResp, err error)
	DetailMenu(ctx context.Context, req *DetailMenuReq, opts ...http.CallOption) (rsp *DetailMenuResp, err error)
	MenuList(ctx context.Context, req *MenuListReq, opts ...http.CallOption) (rsp *MenuListResp, err error)
	UpdateMenu(ctx context.Context, req *UpdateMenuReq, opts ...http.CallOption) (rsp *UpdateMenuResp, err error)
}

type AuthorityHTTPClientImpl struct {
	cc *http.Client
}

func NewAuthorityHTTPClient(client *http.Client) AuthorityHTTPClient {
	return &AuthorityHTTPClientImpl{client}
}

func (c *AuthorityHTTPClientImpl) CreateMenu(ctx context.Context, in *CreateMenuReq, opts ...http.CallOption) (*CreateMenuResp, error) {
	var out CreateMenuResp
	pattern := "/authority/v1/menu/create"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAuthorityCreateMenu))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthorityHTTPClientImpl) DeleteMenu(ctx context.Context, in *DeleteMenuReq, opts ...http.CallOption) (*DeleteMenuResp, error) {
	var out DeleteMenuResp
	pattern := "/authority/v1/menu/delete"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationAuthorityDeleteMenu))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthorityHTTPClientImpl) DetailMenu(ctx context.Context, in *DetailMenuReq, opts ...http.CallOption) (*DetailMenuResp, error) {
	var out DetailMenuResp
	pattern := "/authority/v1/menu/detail"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAuthorityDetailMenu))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthorityHTTPClientImpl) MenuList(ctx context.Context, in *MenuListReq, opts ...http.CallOption) (*MenuListResp, error) {
	var out MenuListResp
	pattern := "/authority/v1/menu/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAuthorityMenuList))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthorityHTTPClientImpl) UpdateMenu(ctx context.Context, in *UpdateMenuReq, opts ...http.CallOption) (*UpdateMenuResp, error) {
	var out UpdateMenuResp
	pattern := "/authority/v1/menu/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAuthorityUpdateMenu))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
